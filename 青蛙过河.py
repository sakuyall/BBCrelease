"""
//结果输出:跳跃能力y

家位置为0, 中间有n-1个石头, 校位置为n(河宽为n)
跳跃距离为下标相减, 起跳后原石头下降1(离开该位置后减1), 高度为0的石头无法到达

将往返过程看作2次从家到学校的单向运动, 除了消耗石头的顺序不同外都一样
所以在青蛙前方长度为y的区间[i, i+y-1], 也就是青蛙的落地范围
由于石头的数量有限, 青蛙需要每次尽可能的跳的更远, 而不是多次消耗石头来跳出一个区间
也就是下表能直接0-3的情况下, 不0-1-2-3慢慢走, 避免过多消耗某个区间

对于宽度为6的河, 假如跳跃能力为3:
位置: 0   1   2   3   4   5   6
高度: 岸  H1  H2  H3  H4  H5  岸
      蛙 [st     ed]

即2x次过河中至少消耗区间[i, i+y]内2x个石头高度
尽管过河时区间会发生滑动或重叠
只要保证河中任意长度为y的区间内, 都有足够的总高度2x, 就能支持2x次过河

设计的路径就是, 使得 //每次过河只消耗 //每个区间仅1次
如果所有长度为y的区间内部的总高度都满足>=2x
那么存在一种跳跃方案完成2x次单向过河, 且每次过河对每个区间最多消耗1个高度
接着, 在第一次过河后每个区间剩余高度>=2x-1, 也就满足后续需求

极限一些的想法:
y=1: 必须每个位置都有足够高度2x  y=n: 直接跳过去
青蛙跳跃距离为1, 每次只能一步一步走, 每次过河都通过全部石头
一次消耗一块石头1高度, 2x次便消耗2x高度
此时长度为y也就是1的"区间"便包含了一块高度2x的石头, 也就是总高度2x, 单次过河走过了n-1个区间

//实现:
y越大, 青蛙能跨过的区间越长, 对石头高度的依赖越小, 越容易完成往返
设定y的范围最小为1, 最大为n(直接跳到对岸)
因此对于这个给定石头数和河宽度的问题, 暴力枚举y从1到n的情况可能超时
可以二分查找最小的y来完成任务, 这时y-1做不到

使用这个y来检查先前提到的2x总高度问题
"""
# 设计检查函数
def check(y, n, x, H):
    """
    这里建立了前缀和列表, 它的意思是:
    pref[0] = 0
    pref[1] = H[0]
    pref[2] = H[0] + H[1] = pref[1] + H[1]
    ...
    pref[k] = H[0] + H[1] + ... + H[k-1] (也就是前k个位置的石头高度和)
    """
    if y >= n:
        return True    # 跳跃能力大于河宽n可以直接跳过
    pref = [0] * n
    for i in range(1, n):
        pref[i] = pref[i-1] + H[i-1] # 可以由上边的推导写出来

    for i in range(1, n - y + 1):    # 检查每个长度y区间[i, i+y-1]的石头高度和
        if i+y-1 < n:     
            # 右边界未到岸边n
            total = pref[i+y-1] - pref[i-1]    # 右边界往左全部 - 左边界前全部 = 区间内全部
        else:
            # 超过岸边部分没有石头了不用计算
            total = pref[n-1] - pref[i-1]
        if total < 2 * x:                      # 不满足检查条件
            return False
    return True        # 在上一步的y发生False后会退出并重新寻找y, 直到合适的y触发此True

def main():
    n, x = map(int, input().split())     # 河的宽度, 上学的天数
    H = list(map(int, input().split()))  # 包含n-1个石头高度的列表
    # 执行二分
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if check(mid, n, x, H):
            # 中点满足检查函数, 继续寻找更小的y, 寻找左半
            right = mid
        else:
            # 不满足检查函数, 找右半
            left = mid + 1
    # 查找区间缩没了, 此时left == right, 返回最终结果
    print(left)

if __name__ == "__main__":
    main()